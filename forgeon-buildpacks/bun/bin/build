#!/usr/bin/env bash
set -euo pipefail

log() { echo "[bun-buildpack] $*"; }
die() { echo "[bun-buildpack] ERROR: $*" >&2; exit 1; }

layers_dir="${CNB_LAYERS_DIR:?CNB_LAYERS_DIR is required}"

layer_name="bun"
layer_dir="${layers_dir}/${layer_name}"
mkdir -p "${layer_dir}/bin"

# ----------------------------
# Config (BP_* envs)
# ----------------------------
BUN_VERSION="${BP_BUN_VERSION:-1.1.0}"

# Auto-detect arch (override by BP_BUN_DIST)
if [[ -n "${BP_BUN_DIST:-}" ]]; then
  BUN_DIST="${BP_BUN_DIST}"
else
  arch="$(uname -m || true)"
  case "$arch" in
    x86_64|amd64)  BUN_DIST="linux-x64" ;;
    aarch64|arm64) BUN_DIST="linux-aarch64" ;;
    *) die "Unsupported arch '$arch'. Set BP_BUN_DIST manually." ;;
  esac
fi

# If we’re x64 but AVX2 is missing, use Bun baseline build to avoid illegal instruction.
if [[ "$BUN_DIST" == "linux-x64" ]]; then
  if [[ -r /proc/cpuinfo ]]; then
    if ! grep -qE '(^|[[:space:]])avx2([[:space:]]|$)' /proc/cpuinfo; then
      log "AVX2 not detected; switching to linux-x64-baseline to avoid Illegal Instruction."
      BUN_DIST="linux-x64-baseline"
    fi
  else
    log "Cannot read /proc/cpuinfo; switching to linux-x64-baseline for safety."
    BUN_DIST="linux-x64-baseline"
  fi
fi

bun_bin="${layer_dir}/bin/bun"

# ----------------------------
# Mark layer types (IMPORTANT)
# ----------------------------
# ✅ launch=true is REQUIRED so launch.toml + bun binary participate in final image launch metadata.
cat > "${layers_dir}/${layer_name}.toml" <<'EOF'
[types]
build = true
launch = true
cache = true
EOF

# ----------------------------
# Safe temp dir handling
# ----------------------------
TMP_DIR=""
cleanup_tmp() {
  if [[ -n "${TMP_DIR:-}" && -d "${TMP_DIR:-}" ]]; then
    rm -rf "${TMP_DIR}"
  fi
  TMP_DIR=""
}

# ----------------------------
# Helpers
# ----------------------------
curl_download() {
  local url="$1" out="$2"
  curl -fsSL "$url" -o "$out"
}

curl_status() {
  local url="$1"
  curl -sS -o /dev/null -w "%{http_code}" "$url" || echo "000"
}

extract_zip_if_possible() {
  local zip="$1" outdir="$2"
  mkdir -p "$outdir"
  if command -v unzip >/dev/null 2>&1; then
    unzip -q "$zip" -d "$outdir"
    return 0
  fi
  if command -v bsdtar >/dev/null 2>&1; then
    bsdtar -xf "$zip" -C "$outdir"
    return 0
  fi
  return 1
}

extract_tgz() {
  local tgz="$1" outdir="$2"
  mkdir -p "$outdir"
  command -v tar >/dev/null 2>&1 || die "tar not found (needed for .tgz fallback)"
  tar -xzf "$tgz" -C "$outdir"
}

find_bun_binary() {
  local root="$1"
  find "$root" -type f -name bun -maxdepth 8 2>/dev/null | head -n 1 || true
}

npm_pkg_for_dist() {
  local dist="$1"
  case "$dist" in
    linux-x64)           echo "@oven/bun-linux-x64" ;;
    linux-x64-baseline)  echo "@oven/bun-linux-x64-baseline" ;;
    linux-aarch64)       echo "@oven/bun-linux-aarch64" ;;
    *) return 1 ;;
  esac
}

npm_name_from_pkg() {
  local pkg="$1"
  echo "${pkg#@oven/}"
}

npm_constructed_tarball_url() {
  local pkg="$1" ver="$2"
  local name; name="$(npm_name_from_pkg "$pkg")"
  echo "https://registry.npmjs.org/${pkg}/-/${name}-${ver}.tgz"
}

install_bun() {
  if [[ -x "$bun_bin" ]]; then
    log "Bun already installed (cached layer)."
    return 0
  fi

  log "Installing Bun ${BUN_VERSION} (${BUN_DIST})..."

  TMP_DIR="$(mktemp -d)"
  local tmp="${TMP_DIR}"

  # 1) GitHub ZIP
  local url_zip="https://github.com/oven-sh/bun/releases/download/bun-v${BUN_VERSION}/bun-${BUN_DIST}.zip"
  log "Trying GitHub ZIP: ${url_zip}"

  if curl_download "$url_zip" "${tmp}/bun.zip" 2>/dev/null; then
    if extract_zip_if_possible "${tmp}/bun.zip" "${tmp}/bun"; then
      local found; found="$(find_bun_binary "${tmp}/bun")"
      if [[ -n "$found" ]]; then
        cp "$found" "$bun_bin"
        chmod +x "$bun_bin"
        cleanup_tmp
        log "Installed Bun from GitHub ZIP."
        return 0
      fi
      log "GitHub ZIP extracted but bun not found; will try npm fallback."
    else
      log "ZIP downloaded but no unzip/bsdtar available; will try npm fallback."
    fi
  else
    log "GitHub ZIP download failed; will try npm fallback."
  fi

  # 2) npm TGZ fallback
  local pkg
  pkg="$(npm_pkg_for_dist "$BUN_DIST")" || die "No npm mapping for BUN_DIST='${BUN_DIST}'"
  local url_tgz
  url_tgz="$(npm_constructed_tarball_url "$pkg" "$BUN_VERSION")"

  log "Trying npm tarball: ${url_tgz}"
  local code; code="$(curl_status "$url_tgz")"
  if [[ "$code" != "200" ]]; then
    die "npm tarball not found for ${pkg}@${BUN_VERSION} (HTTP ${code})."
  fi

  curl_download "$url_tgz" "${tmp}/bun.tgz"
  extract_tgz "${tmp}/bun.tgz" "${tmp}/bun"

  local found
  found="$(find_bun_binary "${tmp}/bun")"
  [[ -n "$found" ]] || die "npm tarball extracted but bun binary not found."

  cp "$found" "$bun_bin"
  chmod +x "$bun_bin"
  cleanup_tmp
  log "Installed Bun from npm tarball."
}

has_script() {
  local name="$1"
  [[ -f package.json ]] && grep -Eq "\"${name}\"[[:space:]]*:" package.json
}

pick_start_script() {
  # Priority:
  # 1) BP_BUN_START_SCRIPT
  # 2) package.json scripts.start
  # 3) package.json scripts.dev
  # 4) "start" fallback
  local script="${BP_BUN_START_SCRIPT:-}"
  if [[ -n "$script" ]]; then
    echo "$script"
    return 0
  fi

  if [[ -f package.json ]]; then
    if grep -Eq '"start"[[:space:]]*:' package.json; then
      echo "start"
      return 0
    fi
    if grep -Eq '"dev"[[:space:]]*:' package.json; then
      echo "dev"
      return 0
    fi
  fi

  echo "start"
}

write_launch_metadata() {
  local proc_type="${BP_BUN_PROCESS_TYPE:-web}"
  local script; script="$(pick_start_script)"

  # ✅ Process metadata (what fixes your error)
  # Processes must live at: <layers>/launch.toml  ✅
  # Append-safe: won’t break future multi-buildpack chains
  cat >> "${layers_dir}/launch.toml" <<EOF
[[processes]]
type = "${proc_type}"
command = "bun"
args = ["run", "${script}"]
default = true
EOF


  # ✅ exec.d fallback (extra compatibility)
  mkdir -p "${layer_dir}/exec.d"
  cat > "${layer_dir}/exec.d/${proc_type}" <<EOF
#!/usr/bin/env bash
set -euo pipefail
: "\${PORT:=3000}"
exec bun run "${script}"
EOF
  chmod +x "${layer_dir}/exec.d/${proc_type}"
}

# ----------------------------
# Main
# ----------------------------
install_bun

if [[ -f "package.json" ]]; then
  log "Running bun install..."

  # allow flags like: "--frozen-lockfile --no-cache"
  # shellcheck disable=SC2206
  install_flags=(${BP_BUN_INSTALL_FLAGS:-})

  if [[ -f "bun.lockb" || -f "bun.lock" ]]; then
    log "Lockfile detected; attempting frozen install first..."
    set +e
    "${bun_bin}" install --frozen-lockfile "${install_flags[@]}"
    rc=$?
    set -e
    if [[ $rc -ne 0 ]]; then
      log "Frozen install failed; retrying non-frozen install..."
      "${bun_bin}" install "${install_flags[@]}"
    fi
  else
    "${bun_bin}" install "${install_flags[@]}"
  fi

  # build script override support
  build_script="${BP_BUN_BUILD_SCRIPT:-}"
  if [[ -n "$build_script" ]]; then
    log "BP_BUN_BUILD_SCRIPT set → bun run ${build_script}"
    "${bun_bin}" run "${build_script}"
  elif has_script "build"; then
    log "Detected build script → bun run build"
    "${bun_bin}" run build
  else
    log "No build script found; skipping build."
  fi
else
  log "No package.json found; skipping install/build."
fi

write_launch_metadata
log "✅ Bun buildpack complete."
