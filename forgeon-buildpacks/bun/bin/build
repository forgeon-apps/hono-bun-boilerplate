#!/usr/bin/env bash
set -euo pipefail

log() { echo "[bun-buildpack] $*"; }
die() { echo "[bun-buildpack] ERROR: $*" >&2; exit 1; }

layers_dir="${CNB_LAYERS_DIR:?CNB_LAYERS_DIR is required}"

layer_name="bun"
layer_dir="${layers_dir}/${layer_name}"
mkdir -p "${layer_dir}/bin"

# ----------------------------
# Config
# ----------------------------
BUN_VERSION="${BP_BUN_VERSION:-1.1.0}"

# Auto-detect arch (override by setting BP_BUN_DIST if you really want)
if [[ -n "${BP_BUN_DIST:-}" ]]; then
  BUN_DIST="${BP_BUN_DIST}"
else
  arch="$(uname -m || true)"
  case "$arch" in
    x86_64|amd64)  BUN_DIST="linux-x64" ;;
    aarch64|arm64) BUN_DIST="linux-aarch64" ;;
    *) die "Unsupported arch '$arch'. Set BP_BUN_DIST manually." ;;
  esac
fi

# If we’re x64 but AVX2 is missing, use Bun baseline build to avoid illegal instruction. :contentReference[oaicite:2]{index=2}
# (Common in emulation / restricted CPU feature sets.)
if [[ "$BUN_DIST" == "linux-x64" ]]; then
  if [[ -r /proc/cpuinfo ]]; then
    if ! grep -qE '(^|[[:space:]])avx2([[:space:]]|$)' /proc/cpuinfo; then
      log "AVX2 not detected; switching to linux-x64-baseline to avoid Illegal Instruction."
      BUN_DIST="linux-x64-baseline"
    fi
  else
    # If we can’t read cpu flags, baseline is the safer default for compatibility. :contentReference[oaicite:3]{index=3}
    log "Cannot read /proc/cpuinfo; switching to linux-x64-baseline for safety."
    BUN_DIST="linux-x64-baseline"
  fi
fi

bun_bin="${layer_dir}/bin/bun"

# ----------------------------
# Mark layer types
# ----------------------------
cat > "${layers_dir}/${layer_name}.toml" <<'EOF'
[types]
build = true
launch = true
cache = true
EOF

# ----------------------------
# Safe temp dir handling (no EXIT trap with unbound vars)
# ----------------------------
TMP_DIR=""
cleanup_tmp() {
  if [[ -n "${TMP_DIR:-}" && -d "${TMP_DIR:-}" ]]; then
    rm -rf "${TMP_DIR}"
  fi
  TMP_DIR=""
}

# ----------------------------
# Helpers
# ----------------------------
curl_download() {
  local url="$1" out="$2"
  curl -fsSL "$url" -o "$out"
}

curl_status() {
  local url="$1"
  curl -sS -o /dev/null -w "%{http_code}" "$url" || echo "000"
}

extract_zip_if_possible() {
  local zip="$1" outdir="$2"
  mkdir -p "$outdir"
  if command -v unzip >/dev/null 2>&1; then
    unzip -q "$zip" -d "$outdir"
    return 0
  fi
  if command -v bsdtar >/dev/null 2>&1; then
    bsdtar -xf "$zip" -C "$outdir"
    return 0
  fi
  return 1
}

extract_tgz() {
  local tgz="$1" outdir="$2"
  mkdir -p "$outdir"
  command -v tar >/dev/null 2>&1 || die "tar not found (needed for .tgz fallback)"
  tar -xzf "$tgz" -C "$outdir"
}

find_bun_binary() {
  local root="$1"
  find "$root" -type f -name bun -maxdepth 8 2>/dev/null | head -n 1 || true
}

npm_pkg_for_dist() {
  local dist="$1"
  case "$dist" in
    linux-x64)           echo "@oven/bun-linux-x64" ;;
    linux-x64-baseline)  echo "@oven/bun-linux-x64-baseline" ;; # baseline build exists on npm :contentReference[oaicite:4]{index=4}
    linux-aarch64)       echo "@oven/bun-linux-aarch64" ;;
    *) return 1 ;;
  esac
}

npm_name_from_pkg() {
  local pkg="$1"
  echo "${pkg#@oven/}"
}

npm_constructed_tarball_url() {
  local pkg="$1" ver="$2"
  local name; name="$(npm_name_from_pkg "$pkg")"
  echo "https://registry.npmjs.org/${pkg}/-/${name}-${ver}.tgz"
}

install_bun() {
  if [[ -x "$bun_bin" ]]; then
    log "Bun already installed (cached layer)."
    return 0
  fi

  log "Installing Bun ${BUN_VERSION} (${BUN_DIST})..."

  TMP_DIR="$(mktemp -d)"
  # ensure temp gets cleaned even if install fails
  # (manual cleanup, not EXIT trap)
  local tmp="${TMP_DIR}"

  # ----------------------------
  # 1) Try GitHub ZIP (fast path if we can extract ZIP)
  # ----------------------------
  local url_zip="https://github.com/oven-sh/bun/releases/download/bun-v${BUN_VERSION}/bun-${BUN_DIST}.zip"
  log "Trying GitHub ZIP: ${url_zip}"

  if curl_download "$url_zip" "${tmp}/bun.zip" 2>/dev/null; then
    if extract_zip_if_possible "${tmp}/bun.zip" "${tmp}/bun"; then
      local found; found="$(find_bun_binary "${tmp}/bun")"
      if [[ -n "$found" ]]; then
        cp "$found" "$bun_bin"
        chmod +x "$bun_bin"
        cleanup_tmp
        log "Installed Bun from GitHub ZIP."
        return 0
      fi
      log "GitHub ZIP extracted but bun not found; will try npm fallback."
    else
      log "ZIP downloaded but no unzip/bsdtar available; will try npm fallback."
    fi
  else
    log "GitHub ZIP download failed; will try npm fallback."
  fi

  # ----------------------------
  # 2) npm TGZ fallback (tar only)
  # ----------------------------
  local pkg
  pkg="$(npm_pkg_for_dist "$BUN_DIST")" || die "No npm mapping for BUN_DIST='${BUN_DIST}'"
  local url_tgz
  url_tgz="$(npm_constructed_tarball_url "$pkg" "$BUN_VERSION")"

  log "Trying npm tarball: ${url_tgz}"

  if [[ "$(curl_status "$url_tgz")" != "200" ]]; then
    die "npm tarball not found for ${pkg}@${BUN_VERSION} (HTTP $(curl_status "$url_tgz"))."
  fi

  curl_download "$url_tgz" "${tmp}/bun.tgz"
  extract_tgz "${tmp}/bun.tgz" "${tmp}/bun"

  local found
  found="$(find_bun_binary "${tmp}/bun")"
  if [[ -z "$found" ]]; then
    die "npm tarball extracted but bun binary not found."
  fi

  cp "$found" "$bun_bin"
  chmod +x "$bun_bin"
  cleanup_tmp
  log "Installed Bun from npm tarball."
}

has_script() {
  local name="$1"
  [[ -f package.json ]] && grep -Eq "\"${name}\"[[:space:]]*:" package.json
}

write_launch_toml() {
  # Processes must live at: <layers>/<layer>/launch.toml
  cat > "${layer_dir}/launch.toml" <<EOF
[[processes]]
type = "web"
command = ["bun"]
args = ["run", "${BP_BUN_START_SCRIPT:-start}"]
default = true
EOF
}

# ----------------------------
# Main
# ----------------------------
install_bun

# CNB runs build with working directory already at app root.
if [[ -f "package.json" ]]; then
  log "Running bun install..."

  # If bun still throws Illegal instruction here, the CPU is below Bun's baseline requirement (SSE4.2). :contentReference[oaicite:5]{index=5}
  install_flags=(${BP_BUN_INSTALL_FLAGS:-})

  if [[ -f "bun.lockb" || -f "bun.lock" ]]; then
    log "Lockfile detected; attempting frozen install first..."
    set +e
    "${bun_bin}" install --frozen-lockfile "${install_flags[@]}"
    rc=$?
    set -e

    if [[ $rc -ne 0 ]]; then
      log "Frozen install failed (lockfile mismatch). Retrying non-frozen install..."
      "${bun_bin}" install "${install_flags[@]}"
    fi
  else
    "${bun_bin}" install "${install_flags[@]}"
  fi

  if has_script "build"; then
    log "Running bun run build..."
    "${bun_bin}" run build
  else
    log "No build script found; skipping build."
  fi
else
  log "No package.json found; skipping install/build."
fi

write_launch_toml
log "✅ Bun buildpack complete."
